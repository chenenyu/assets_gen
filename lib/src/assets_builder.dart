import 'dart:async';
import 'dart:io';
import 'dart:math';

import 'package:build/build.dart';
import 'package:glob/glob.dart';
import 'package:path/path.dart' as p;
import 'package:yaml/yaml.dart';

import 'options.dart';

Builder assetsBuilder(BuilderOptions options) => AssetsBuilder();

const String options_file = 'assets_gen_options.yaml';
const String pubspec_file = 'pubspec.yaml';

class AssetsBuilder implements Builder {
  AssetsBuilder();

  AssetsGenOptions _options;

  @override
  Map<String, List<String>> get buildExtensions {
    _prepare();
    return {
      r'$lib$': [_options.output]
    };
  }

  @override
  FutureOr<void> build(BuildStep buildStep) async {
//    print('AssetsBuilder#build');
    _prepare();
    AssetId id = buildStep.inputId; // package|lib/$lib$

    Iterable<String> assets =
        await _readAssetsFromPubspec(buildStep, id.package);
    if (assets == null) {
      return null;
    }
    Iterable<String> paths = await _findAssets(buildStep, assets);

    AssetId gen = AssetId(id.package, p.join('lib', _options.output));
    await buildStep.writeAsString(gen, _generate(id.package, paths));
    return null;
  }

  /// Update options
  void _prepare() {
    if (_options != null) {
      return;
    }
    _options = AssetsGenOptions();

    // update from pubspec
    File pubspecFile = File(pubspec_file);
    if (!pubspecFile.existsSync()) {
      return;
    }
    YamlMap pubspecYaml = loadYaml(pubspecFile.readAsStringSync());
    if (pubspecYaml.containsKey('assets_gen')) {
      final assets_gen = pubspecYaml['assets_gen'];
      if (assets_gen is YamlMap) {
        _options.update(assets_gen);
      }
    }

    // update from options file
    File optionsFile = File(options_file);
    if (!optionsFile.existsSync()) {
      log.fine('$options_file not exists.');
      return;
    }
    final optionsYaml = loadYaml(optionsFile.readAsStringSync());
    if (optionsYaml == null || optionsYaml.isEmpty) {
      log.info('$options_file is empty.');
      return;
    }
    if (optionsYaml is! YamlMap) {
      log.warning(
          '$options_file(${optionsYaml.runtimeType}) is not map format.');
      return;
    }
    _options.update(optionsYaml.value);
  }

  /// Read assets from pubspec
  Future<Iterable<String>> _readAssetsFromPubspec(
      BuildStep buildStep, String package) async {
    AssetId pubspec = AssetId(package, pubspec_file);
    if ((await buildStep.canRead(pubspec)) != true) {
      log.severe('Can not read ${pubspec.toString()}.');
      return null;
    }
    String yaml = await buildStep.readAsString(pubspec);
    YamlMap yamlMap = loadYaml(yaml);
    if (!yamlMap.containsKey('flutter')) {
      log.severe(
          'Ignored: ${pubspec.toString()} does not contain \'flutter\' section.');
      return null;
    }
    YamlMap flutter = yamlMap['flutter'];

    if (!flutter.containsKey('assets')) {
      log.severe(
          'Ignored: ${pubspec.toString()} does not contain \'assets\' section.');
      return null;
    }
    YamlList assets = flutter['assets'];
    if (assets.isEmpty) {
      log.warning(
          'Ignored: ${pubspec.toString()} contains empty \'assets\' section.');
      return null;
    }
    return List<String>.from(assets);
  }

  Future<Iterable<String>> _findAssets(
      BuildStep buildStep, Iterable<String> assets) async {
    Set<String> validAssets = assets.toSet();
    Set<String> paths = <String>{};
    for (String asset in validAssets) {
      // log.fine(asset);
      if (asset.endsWith('/')) {
        // dir
        Glob glob = Glob('$asset*', recursive: false, caseSensitive: false);
        Set<AssetId> assets = await buildStep.findAssets(glob).toSet();
        if (assets.isNotEmpty) {
          assets.forEach((assetId) {
            if (!_options.shouldExclude(assetId.path)) {
              paths.add(assetId.path);
            }
          });
        } else {
          Directory dir = Directory(asset);
          if (dir.existsSync()) {
            Iterable<FileSystemEntity> children =
                dir.listSync().whereType<File>();
            children.forEach((f) {
              if (!_options.shouldExclude(f.path)) {
                paths.add(f.path);
              }
            });
          }
        }
      } else {
        // file
        if (!_options.shouldExclude(asset)) {
          paths.add(asset);
        }
      }
    }
    return List<String>.from(paths)..sort();
  }

  String _generate(String package, Iterable<String> paths) {
    StringBuffer content = StringBuffer();
    content.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    content.writeln();
    content.writeln(
        '// **************************************************************************');
    content.writeln('// Total assets: ${paths.length}.');
    content.writeln('// Generated by https://pub.dev/packages/assets_gen.');
    content.writeln(
        '// **************************************************************************');

    content.writeln('class ${_options.className} {');
    content.writeln("  static const String package = '${package}';");
    for (String path in paths) {
      content.writeln();

      String key = path;
      if (_options.omitPathLevels > 0) {
        // 省略路径层级
        List<String> pathSegments = p.split(p.dirname(path));
        if (pathSegments.isNotEmpty) {
          pathSegments = pathSegments
              .sublist(min(_options.omitPathLevels, pathSegments.length));
          key = p.join(p.joinAll(pathSegments), p.basename(path));
        }
      }
      // 替换非法字符
      key = key.replaceAll('/', '_').replaceAll('-', '_').replaceAll('.', '_');
      // 如果key不是以字母或$开头，前面加一个$
      content.writeln(
          "  static const String ${key.startsWith(RegExp(r'[a-zA-Z$]')) ? '' : '\$'}$key = '${path}';");
      if (_options.genPackagePath && !path.startsWith('packages/${package}')) {
        content.writeln(
            "  static const String ${package}\$$key = 'packages/${package}/${path}';");
      }
    }
    content.writeln('}');

    return content.toString();
  }
}
